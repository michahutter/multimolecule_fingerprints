#!/usr/bin/perl -w
#
use Math::BigInt lib => 'GMP'; # warn if BigInt is not present
#use Math::BigInt ;
use bigint ;

#  calculate multi molecule fingerprint (scaled Dice similarity, using bit masking)
#  mmfp_dice_masked.pl
#
#  removed condition for denominator scaling!!!
#
# requires following other programs:
#
# libmath-bigint-gmp-perl
#
# (apt-get install libmath-bigint-gmp-perl)
#
#
# Usage: mmfp_dice_masked.pl compounds_with_fps mmfp_db.asc
#
# compounds_with_fps = list of molecule with their fingerprints
# mmfp_db.asc = MMFP frequencies as previously generated by gen_mmfp.pl
#
# Format of compounds_with_fps:
#
# c1ccccc1 benzene 0x0ecf1s...(MACSS) 0x176000...(PubChem)
#
# Output:
# SMILES#1 mmfp-similarity
# SMILES#2 mmfp-similarity
# [...]

# masking strings derived from cleaned Dark Chemical Matter set
# Bits that are not set in these strings do not appear and are
# neglected upon calculating the similarity
#
$mk[1] = Math::BigInt->new('0xffffc70f9fffffffffffffffffffffffffffffffe') ; # MACCS
$mk[2] = Math::BigInt->new('0x1e1ffe5cccccccc88cccc863c400065e200afe301ff84aff8a57fc512dffffffffffffffffffffffffffdeeffffefeefffbfffeff6ffdeffebff77fddb7d87e7fedff5ffefffc1fc3d7ffbd7fffffff7bffffffffff004c477df1f06800ffffffffffefcf000000000000400037bc') ; # PubChem

 
$SMILES = $ARGV[0] ; 
$MMFPDB = "" ;

if (defined($ARGV[1])) {
  $MMFPDB = $ARGV[1];
}
else {
  print "missing a MMFP file!\n";
  die ;
}


if (-e "$SMILES") { print "list of SMILES $SMILES found\n" } 
  else { print "$SMILES not found\n" ; die }

if (-e "$MMFPDB") { print "file $MMFPDB found\n" } 
  else { print "$MMFPDB not found\n" ; die }

my @cols ;               # holds the columns in each line
$nfp = 0; # number of fingerprints

#
# read in MMFP file first
 
open(MMFP,$MMFPDB) or die "error opening MMFPDB : $!\n" ;

$nline = 0 ;

while(defined($i = <MMFP>)) {
  $nline++;
  #  my @cols = split(/\s+/,$i);
  my @cols = split(/[\s\t]/,$i); # split line at spaces or tabs
  if (defined($cols[1])) {  # start of new fingerprint
#   print "\n" ;
    $nfp++;
    $lfp[$nfp] = $cols[0] ; # number of fingerprint bits
    $nc = 0 ; # reset counter 
    next ;
  }
  $nc++;
# $mmfp[$nfp][$nc] = $cols[0] ;
  $mmfp[$nfp][$nc] = sprintf '%7.5f', $cols[0] ;
# print "$mmfp[$nfp][$nc] " ;
}
#print "\n" ;

close(MMFP);

print "number of fingerprints $nfp\n" ;


open(LIST,$SMILES) or die "error opening $SMILES : $!\n"; 

$ncomp = -1;  # number of compounds

while(defined($i = <LIST>)) {
  $ncomp++;
  if ($ncomp == 0) { # first line holds text
    next ;
  }
  #  my @cols = split(/\s+/,$i);
# c1ccccc1 benzene 0x0ecf1s...(MACSS) 0x176000...(PubChem)
  my @cols = split(/[\s\t]/,$i); # split line at spaces or tabs
  $smile[$ncomp] = $cols[0] ;
  $name[$ncomp]  = $cols[1] ;
  for ($j = 1; $j <= $nfp; $j++) { # read fingerprints as hex numbers
     $fp[$ncomp][$j] = Math::BigInt->new($cols[$j+1]) ;
  }
}

close(LIST);

$lfpmax = 0 ; # number of bits in largest fingerprint
for ($k = 1; $k <= $nfp; $k++) { 
  if ($lfp[$k] > $lfpmax) {$lfpmax = $lfp[$k]}
}
#print "lfpmax $lfpmax \n" ;

for ($k = 0; $k < $lfpmax; $k++) { # init bits for logical AND comparison
  $bit[$k+1] = Math::BigInt->new(2**$k) ;
# print $bit[$k+1]->as_hex(), "\n" ;
}

print "SMILES name similarities\n";

$zero = sprintf '%7.5f', 0.0e0 ;
$one = sprintf '%7.5f', 1.0e0 ;
$two = sprintf '%7.5f', 2.0e0 ;
#$thres = sprintf '%7.5f', 0.0001e0 ;

for ($l = 1; $l <= $ncomp; $l++) { # loop over compounds
  print "$smile[$l] $name[$l] ";
  for ($m = 1; $m <= $nfp; $m++) { # loop over fingerprints
    $stmp1 = sprintf '%7.5f', 0.0e0 ;
    $stmp2 = sprintf '%7.5f', 0.0e0 ;
    for ($k = 1; $k <= $lfp[$m]; $k++) { # loop over bits in fingerprint
##    $bmask = $bit[$k] & $mk[$m] ; # bit is not masked
#     print "$m $bmask\n" ;
##    if ($bmask < 1) {next}
#     $tsum = $bit[$k]->band($fp[$l][$m]); # both version of AND work
      $tsum = $bit[$k] & $fp[$l][$m] ; # bit in query molecules is set
#     print "$tsum " ;
      $xia = $mmfp[$m][$k] ; # X_iA is between -1 and +1
      if ($tsum > 0) { # X_iB is either zero or one
        $xib = $one ;
      }
      else {
        $xib = $zero ;
      }
      $absia = abs($xia)  ;

#     denominator scaling removed !!!
      $xiab  = $xib * $absia ; # scale X_iB 
      $stmp1 = $stmp1 + $xia * $xiab;                 # nominator
      $stmp2 = $stmp2 + $xia * $xia + $xiab * $xiab ; # denominator
      
##    original condition for scaling
##    if ($absia != 0) {
##   	$xiab  = $xib * $absia ; # scale X_iB 
##      $stmp1 = $stmp1 + $xia * $xiab;                 # nominator
##	$stmp2 = $stmp2 + $xia * $xia + $xiab * $xiab ; # denominator
##    }
##    else {
##      $stmp2 = $stmp2 + $xib ;
##    }

#     print "xia $xia  xib $xib  absia $absia  stmp1 $stmp1  stmp2 $stmp2\n" ;
    }
#   print "\noben $stmp1 unten $stmp2\n";
    $stmp1 = $stmp1 * $two ;
    if ($stmp2 < 0.0001) {$stmp2 = 0.0001} # avoid division by zero
    $sim = $stmp1 / $stmp2 ; # similarity 
    printf ("%7.5f",$sim);
    print " ";
  }
  print "\n" ;
}

exit(0);

